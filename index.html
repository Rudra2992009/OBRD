<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Object Detector</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Hide the video element, as its content is drawn onto the canvas */
        #videoElement {
            display: none;
        }
        #canvasContainer {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            border-radius: 1.5rem; /* Rounded corners for the entire display */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden; /* Ensures canvas and video stay within rounded container */
        }
        #outputCanvas {
            width: 100%;
            height: auto;
            background: #2d3748; /* Dark background before camera loads */
        }
        .loading-ring {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <!-- Load TensorFlow.js and the COCO-SSD model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
</head>
<body class="p-4 sm:p-6 flex flex-col items-center min-h-screen">

    <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Live Object Detector (COCO-SSD)</h1>

    <!-- Status and Loading Area -->
    <div id="status" class="w-full max-w-lg mb-6 text-center p-3 rounded-lg bg-white shadow-md transition duration-300">
        <div id="loadingMessage" class="flex justify-center items-center space-x-2 text-blue-600 font-semibold">
            <div class="loading-ring"></div>
            <span>Loading model and requesting camera...</span>
        </div>
        <p id="errorMessage" class="text-red-500 font-medium hidden">Error: Could not access camera or load model.</p>
    </div>

    <!-- Main Video/Canvas Container -->
    <div id="canvasContainer" class="w-full">
        <!-- The video element captures the stream but is hidden -->
        <video id="videoElement" playsinline autoplay muted></video>
        <!-- The canvas element displays the stream and the detection results -->
        <canvas id="outputCanvas"></canvas>
    </div>

    <div id="resultBox" class="w-full max-w-lg mt-6 p-4 bg-gray-800 text-white rounded-xl shadow-lg">
        <p class="font-bold text-xl mb-2 text-blue-300">Detection Output:</p>
        <div id="detectionsList" class="text-sm space-y-1">
            <p>Awaiting first detection...</p>
        </div>
    </div>


    <script>
        const videoElement = document.getElementById('videoElement');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const detectionsList = document.getElementById('detectionsList');

        let model = null;
        let videoStream = null;
        let animationFrameId = null;

        // --- Utility Functions ---

        // Function to handle API call retry with exponential backoff
        async function fetchWithRetry(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    // console.warn(`Fetch failed. Retrying in ${delay / 1000}s...`, error.message);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        /**
         * Initializes the camera and starts the video stream.
         */
        async function setupCamera() {
            try {
                // Request camera permission
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment' // Prefer back camera on mobile
                    }
                });
                videoElement.srcObject = videoStream;

                // Wait for the video to load metadata (including dimensions)
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        resolve(videoElement);
                    };
                });

                // Set canvas size to match video size
                outputCanvas.width = videoElement.videoWidth;
                outputCanvas.height = videoElement.videoHeight;

                loadingMessage.classList.add('hidden');
                document.getElementById('status').classList.remove('bg-white');
                document.getElementById('status').classList.add('bg-green-100');
                document.getElementById('status').innerHTML = '<span class="text-green-600 font-semibold">Camera ready. Running detection...</span>';

                startDetection();

            } catch (err) {
                console.error("Error accessing camera:", err);
                loadingMessage.classList.add('hidden');
                errorMessage.classList.remove('hidden');
                document.getElementById('status').classList.remove('bg-white');
                document.getElementById('status').classList.add('bg-red-100');
                document.getElementById('status').innerHTML = '<span class="text-red-600 font-semibold">Error: Camera access denied or not available.</span>';
            }
        }

        /**
         * Loads the COCO-SSD model.
         */
        async function loadModel() {
            try {
                // The load function is part of the cocoSsd library loaded via CDN
                model = await cocoSsd.load();
                // console.log("COCO-SSD model loaded successfully.");
            } catch (err) {
                console.error("Error loading COCO-SSD model:", err);
                loadingMessage.classList.add('hidden');
                errorMessage.classList.remove('hidden');
            }
        }

        /**
         * The main detection loop.
         */
        function startDetection() {
            if (model && videoElement.readyState >= 2) {
                detectFrame();
            } else {
                // Wait for video and model to be ready
                animationFrameId = requestAnimationFrame(startDetection);
            }
        }

        /**
         * Detects objects in the current video frame and draws results.
         */
        async function detectFrame() {
            if (model && videoElement.readyState >= 2) {
                try {
                    // 1. Run detection
                    // The video element must be visible/used as the source
                    const predictions = await model.detect(videoElement);

                    // 2. Draw the frame
                    drawCanvas(predictions);

                    // 3. Update the UI list
                    updateDetectionsList(predictions);

                } catch (err) {
                    console.error("Error during detection:", err);
                }
            }

            // Request the next frame
            animationFrameId = requestAnimationFrame(detectFrame);
        }

        /**
         * Draws the current video frame and the detection boxes on the canvas.
         */
        function drawCanvas(predictions) {
            // Draw the current video frame
            ctx.drawImage(videoElement, 0, 0, outputCanvas.width, outputCanvas.height);

            ctx.font = '16px "Inter", sans-serif';
            ctx.lineWidth = 3;

            predictions.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                const score = (prediction.score * 100).toFixed(1);

                // Check confidence score
                if (prediction.score < 0.60) return; // Skip low confidence detections

                // 1. Draw Bounding Box (in a nice blue color)
                ctx.strokeStyle = '#3b82f6';
                ctx.strokeRect(x, y, width, height);

                // 2. Draw Label Background
                const text = `${prediction.class} (${score}%)`;
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = 24; // Fixed height for background

                ctx.fillStyle = '#3b82f6';
                // Adjust y position to keep it inside the canvas boundary if close to top
                const labelY = (y > textHeight) ? y - textHeight + 5 : y + 5;
                ctx.fillRect(x, labelY, textWidth + 10, textHeight);

                // 3. Draw Text
                ctx.fillStyle = 'white';
                ctx.fillText(text, x + 5, labelY + 16);
            });
        }

        /**
         * Updates the list of detected objects in the result box.
         */
        function updateDetectionsList(predictions) {
            detectionsList.innerHTML = ''; // Clear previous list
            const confidentPredictions = predictions.filter(p => p.score >= 0.60);

            if (confidentPredictions.length === 0) {
                detectionsList.innerHTML = '<p class="text-gray-400">No objects detected (Confidence > 60%).</p>';
                return;
            }

            confidentPredictions.sort((a, b) => b.score - a.score); // Sort by confidence

            confidentPredictions.forEach(prediction => {
                const score = (prediction.score * 100).toFixed(1);
                const listItem = document.createElement('p');
                listItem.className = 'text-green-300 font-medium';
                listItem.innerHTML = `<strong>${prediction.class}</strong>: ${score}% confidence`;
                detectionsList.appendChild(listItem);
            });
        }

        /**
         * Initialization function.
         */
        async function init() {
            await loadModel();
            await setupCamera();
        }

        // Clean up when the tab/window closes (optional but good practice)
        window.onbeforeunload = function() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
        };

        // Start the application
        window.onload = init;
    </script>

</body>
</html>

